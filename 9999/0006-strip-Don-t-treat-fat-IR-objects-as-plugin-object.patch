https://inbox.sourceware.org/binutils/CAMe9rOprvH1SusdkbmAnE7L0Sr4kYeMZTYAQBw4t9oTySVsgjw@mail.gmail.com/

From a0fafaa5186a248ac75e178d39fa257ddbce5f2d Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Sun, 3 Aug 2025 10:28:40 -0700
Subject: [PATCH] strip: Don't treat fat IR objects as plugin object

Fat IR objects contains both regular sections and IR sections.  After

commit 717a38e9a02109fcbcb18bb2ec3aa251e2ad0a0d
Author: H.J. Lu <hjl.tools@gmail.com>
Date:   Sun May 4 05:12:46 2025 +0800

    strip: Add GCC LTO IR support

"strip --strip-debug" no longer strips debug sections in fat IR objects
since fat IR objects are recognized as plugin object and copied as unknown
objects.  Update strip not to treat archive member nor standalone fat IR
object as IR object so that strip can remove debug and IR sections in
fat IR object.  For archive member, it is copied as an unknown object if
it isn't a fat IR object nor a slim IR object.

bfd/

	PR binutils/33246
	* archive.c: Include "plugin-api.h" and "plugin.h" if plugin is
	enabled.
	(_bfd_compute_and_write_armap): Don't complain plugin is needed
	when the plugin target is in use.
	* bfd-in2.h: Regenerated.
	* format.c (bfd_check_format_lto): Removed.
	(bfd_check_format): Updated.
	(bfd_set_lto_type): If there is .llvm.lto section, set LTO type
	to lto_fat_ir_object.
	(bfd_check_format_matches_lto): Removed.
	(bfd_check_format_matches): Don't set LTO type when setting
	format.  When called from strip, don't treat archive
	member nor standalone fat IR object as an IR object.
	* plugin.c (bfd_plugin_get_symbols_in_object_only): Copy LTO
	type derived from input sections.

nm/

	PR binutils/33246
	* nm.c (filter_symbols): Don't complain plugin is needed when
	the plugin target is in use.
	(display_rel_file): Likewise.
	* objcopy.c (copy_archive): Pass true to bfd_check_format_lto
	to indicat called from strip.  Also copy slim IR archive member
	as unknown object.
	(copy_file): Call bfd_check_format_lto, instead of
	bfd_check_format.  Pass true to bfd_check_format_lto and
	bfd_check_format_matches_lto.
	(strip_main): Keep .gnu.debuglto_* sections unless all GCC LTO
	sections will be removed.

ld/

	PR binutils/33246
	* testsuite/ld-plugin/lto-binutils.exp (run_pr33246_test): New.
	Run binutils/33246 tests with GCC and Clang.
	* testsuite/ld-plugin/pr33246.c: New file.

Co-Authored-By: Alan Modra <amodra@gmail.com>
Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
---
 bfd/archive.c                           |  12 +-
 bfd/bfd-in2.h                           |  10 +-
 bfd/bfd.c                               |   3 +
 bfd/format.c                            | 140 +++++++------------
 bfd/plugin.c                            |   7 +-
 binutils/nm.c                           |   6 +-
 binutils/objcopy.c                      |  57 +++++---
 ld/testsuite/ld-plugin/lto-binutils.exp | 175 ++++++++++++++++++++++++
 ld/testsuite/ld-plugin/pr33246.c        |   4 +
 9 files changed, 290 insertions(+), 124 deletions(-)
 create mode 100644 ld/testsuite/ld-plugin/pr33246.c

diff --git a/bfd/archive.c b/bfd/archive.c
index c61d4b12658..491c44f5191 100644
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -141,6 +141,10 @@ SUBSECTION
 #include "hashtab.h"
 #include "filenames.h"
 #include "bfdlink.h"
+#if BFD_SUPPORTS_PLUGINS
+#include "plugin-api.h"
+#include "plugin.h"
+#endif
 
 #ifndef errno
 extern int errno;
@@ -2342,7 +2346,8 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
 	  long symcount;
 	  long src_count;
 
-	  if (bfd_get_lto_type (current) == lto_slim_ir_object
+	  if (!bfd_plugin_target_p (current->xvec)
+	      && bfd_get_lto_type (current) == lto_slim_ir_object
 	      && report_plugin_err)
 	    {
 	      report_plugin_err = false;
@@ -2398,8 +2403,9 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
 			  map = new_map;
 			}
 
-		      if (bfd_lto_slim_symbol_p (current,
-						 syms[src_count]->name)
+		      if (!bfd_plugin_target_p (current->xvec)
+			  && bfd_lto_slim_symbol_p (current,
+						    syms[src_count]->name)
 			  && report_plugin_err)
 			{
 			  report_plugin_err = false;
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 2ff3e930bfa..12512a3962c 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -2131,6 +2131,9 @@ struct bfd
   /* Set if this is the linker input BFD.  */
   unsigned int is_linker_input : 1;
 
+  /* Set if this is the strip input BFD.  */
+  unsigned int is_strip_input : 1;
+
   /* If this is an input for a compiler plug-in library.  */
   ENUM_BITFIELD (bfd_plugin_format) plugin_format : 2;
 
@@ -2903,15 +2906,8 @@ bool generic_core_file_matches_executable_p
    (bfd *core_bfd, bfd *exec_bfd);
 
 /* Extracted from format.c.  */
-bool bfd_check_format_lto (bfd *abfd, bfd_format format,
-    bool lto_sections_removed);
-
 bool bfd_check_format (bfd *abfd, bfd_format format);
 
-bool bfd_check_format_matches_lto
-   (bfd *abfd, bfd_format format, char ***matching,
-    bool lto_sections_removed);
-
 bool bfd_check_format_matches
    (bfd *abfd, bfd_format format, char ***matching);
 
diff --git a/bfd/bfd.c b/bfd/bfd.c
index 858ab5ce017..4aded6809bb 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -296,6 +296,9 @@ CODE_FRAGMENT
 .  {* Set if this is the linker input BFD.  *}
 .  unsigned int is_linker_input : 1;
 .
+.  {* Set if this is the strip input BFD.  *}
+.  unsigned int is_strip_input : 1;
+.
 .  {* If this is an input for a compiler plug-in library.  *}
 .  ENUM_BITFIELD (bfd_plugin_format) plugin_format : 2;
 .
diff --git a/bfd/format.c b/bfd/format.c
index f3a0774af08..f8e73b7eaea 100644
--- a/bfd/format.c
+++ b/bfd/format.c
@@ -56,19 +56,16 @@ extern const size_t _bfd_target_vector_entries;
 
 /*
 FUNCTION
-	bfd_check_format_lto
+	bfd_check_format
 
 SYNOPSIS
-	bool bfd_check_format_lto (bfd *abfd, bfd_format format,
-				   bool lto_sections_removed);
+	bool bfd_check_format (bfd *abfd, bfd_format format);
 
 DESCRIPTION
 	Verify if the file attached to the BFD @var{abfd} is compatible
 	with the format @var{format} (i.e., one of <<bfd_object>>,
 	<<bfd_archive>> or <<bfd_core>>).
 
-	If LTO_SECTION_REMOVED is true, ignore plugin target.
-
 	If the BFD has been set to a specific target before the
 	call, only the named target and format combination is
 	checked. If the target has not been set, or has been set to
@@ -102,31 +99,10 @@ DESCRIPTION
 	itself.
 */
 
-bool
-bfd_check_format_lto (bfd *abfd, bfd_format format,
-		      bool lto_sections_removed)
-{
-  return bfd_check_format_matches_lto (abfd, format, NULL,
-				       lto_sections_removed);
-}
-
-
-/*
-FUNCTION
-	bfd_check_format
-
-SYNOPSIS
-	bool bfd_check_format (bfd *abfd, bfd_format format);
-
-DESCRIPTION
-	Similar to bfd_check_format_plugin, except plugin target isn't
-	ignored.
-*/
-
 bool
 bfd_check_format (bfd *abfd, bfd_format format)
 {
-  return bfd_check_format_matches_lto (abfd, format, NULL, false);
+  return bfd_check_format_matches (abfd, format, NULL);
 }
 
 struct bfd_preserve
@@ -413,6 +389,11 @@ bfd_set_lto_type (bfd *abfd ATTRIBUTE_UNUSED)
 	    abfd->object_only_section = sec;
 	    break;
 	  }
+	else if (strcmp (sec->name, ".llvm.lto") == 0)
+	  {
+	    type = lto_fat_ir_object;
+	    break;
+	  }
 	else if (lsection.major_version == 0
 		 && startswith (sec->name, ".gnu.lto_.lto.")
 		 && bfd_get_section_contents (abfd, sec, &lsection, 0,
@@ -431,36 +412,32 @@ bfd_set_lto_type (bfd *abfd ATTRIBUTE_UNUSED)
 
 /*
 FUNCTION
-	bfd_check_format_matches_lto
+	bfd_check_format_matches
 
 SYNOPSIS
-	bool bfd_check_format_matches_lto
-	  (bfd *abfd, bfd_format format, char ***matching,
-	   bool lto_sections_removed);
+	bool bfd_check_format_matches
+	  (bfd *abfd, bfd_format format, char ***matching);
 
 DESCRIPTION
 	Like <<bfd_check_format>>, except when it returns FALSE with
-	<<bfd_errno>> set to <<bfd_error_file_ambiguously_recognized>>.  In that
-	case, if @var{matching} is not NULL, it will be filled in with
-	a NULL-terminated list of the names of the formats that matched,
-	allocated with <<malloc>>.
+	<<bfd_errno>> set to <<bfd_error_file_ambiguously_recognized>>.
+	In that case, if @var{matching} is not NULL, it will be filled
+	in with a NULL-terminated list of the names of the formats
+	that matched, allocated with <<malloc>>.
 	Then the user may choose a format and try again.
 
 	When done with the list that @var{matching} points to, the caller
 	should free it.
-
-	If LTO_SECTION_REMOVED is true, ignore plugin target.
 */
 
 bool
-bfd_check_format_matches_lto (bfd *abfd, bfd_format format,
-			      char ***matching,
-			      bool lto_sections_removed ATTRIBUTE_UNUSED)
+bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 {
   extern const bfd_target binary_vec;
   const bfd_target * const *target;
   const bfd_target **matching_vector = NULL;
   const bfd_target *save_targ, *right_targ, *ar_right_targ, *match_targ;
+  const bfd_target *fail_targ;
   int match_count, best_count, best_match;
   int ar_match_index;
   unsigned int initial_section_id = _bfd_section_id;
@@ -481,10 +458,7 @@ bfd_check_format_matches_lto (bfd *abfd, bfd_format format,
     }
 
   if (abfd->format != bfd_unknown)
-    {
-      bfd_set_lto_type (abfd);
-      return abfd->format == format;
-    }
+    return abfd->format == format;
 
   if (matching != NULL || *bfd_associated_vector != NULL)
     {
@@ -524,20 +498,30 @@ bfd_check_format_matches_lto (bfd *abfd, bfd_format format,
   if (!bfd_preserve_save (abfd, &preserve, NULL))
     goto err_ret;
 
-  /* If the target type was explicitly specified, just check that target.
-     If LTO_SECTION_REMOVED is true, don't match the plugin target.  */
+  /* If the target type was explicitly specified, just check that target.  */
+  fail_targ = NULL;
   if (!abfd->target_defaulted
 #if BFD_SUPPORTS_PLUGINS
-      && (!lto_sections_removed || !bfd_plugin_target_p (abfd->xvec))
+      && !(abfd->plugin_format == bfd_plugin_no
+	   && bfd_plugin_target_p (save_targ))
 #endif
-     )
+      )
     {
       if (bfd_seek (abfd, 0, SEEK_SET) != 0)	/* rewind! */
 	goto err_ret;
 
       cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
 
-      if (cleanup)
+      /* When called from strip, don't treat archive member nor
+	 standalone fat IR object as an IR object.  For archive
+	 member, it will be copied as an unknown object if it
+	 isn't a fat IR object.  For standalone fat IR object,
+	 it will be copied as non-IR object.  */
+      if (cleanup
+	  && (!abfd->is_strip_input
+	      || !bfd_plugin_target_p (abfd->xvec)
+	      || (abfd->lto_type != lto_fat_ir_object
+		  && abfd->my_archive == NULL)))
 	goto ok_ret;
 
       /* For a long time the code has dropped through to check all
@@ -554,10 +538,10 @@ bfd_check_format_matches_lto (bfd *abfd, bfd_format format,
 	 target.  */
       if (format == bfd_archive && save_targ == &binary_vec)
 	goto err_unrecog;
+      fail_targ = save_targ;
     }
 
-  /* Since the target type was defaulted, check them all in the hope
-     that one will be uniquely recognized.  */
+  /* Check all targets in the hope that one will be recognized.  */
   right_targ = NULL;
   ar_right_targ = NULL;
   match_targ = NULL;
@@ -571,26 +555,26 @@ bfd_check_format_matches_lto (bfd *abfd, bfd_format format,
       void **high_water;
 
       /* The binary target matches anything, so don't return it when
-	 searching.  Don't match the plugin target if we have another
-	 alternative since we want to properly set the input format
-	 before allowing a plugin to claim the file.  Also, don't
-	 check the default target twice.   If LTO_SECTION_REMOVED is
-	 true, don't match the plugin target.  */
+	 searching.  Also, don't check the current target twice when
+	 it has failed already.
+	 Don't match the plugin target during linking if we have 
+	 another alternative since we want to properly set the input
+	 format before allowing a plugin to claim the file.
+	 Also as an optimisation don't match the plugin target when
+	 abfd->plugin_format is set to bfd_plugin_no.  (This occurs
+	 when LTO sections have been stripped or when we have a
+	 recursive call here from the plugin object_p via
+	 bfd_plugin_get_symbols_in_object_only.)  */
       if (*target == &binary_vec
+	  || *target == fail_targ
 #if BFD_SUPPORTS_PLUGINS
-	  || ((lto_sections_removed || match_count != 0)
+	  || (((abfd->is_linker_input && match_count != 0)
+	       || abfd->plugin_format == bfd_plugin_no)
 	      && bfd_plugin_target_p (*target))
 #endif
-	  || (!abfd->target_defaulted && *target == save_targ))
+	  )
 	continue;
 
-#if BFD_SUPPORTS_PLUGINS
-      /* If the plugin target is explicitly specified when a BFD file
-	 is opened, don't check it twice.  */
-      if (bfd_plugin_specified_p () && bfd_plugin_target_p (*target))
-	continue;
-#endif
-
       /* If we already tried a match, the bfd is modified and may
 	 have sections attached, which will confuse the next
 	 _bfd_check_format call.  */
@@ -831,32 +815,6 @@ bfd_check_format_matches_lto (bfd *abfd, bfd_format format,
   return false;
 }
 
-/*
-FUNCTION
-	bfd_check_format_matches
-
-SYNOPSIS
-	bool bfd_check_format_matches
-	  (bfd *abfd, bfd_format format, char ***matching);
-
-DESCRIPTION
-	Like <<bfd_check_format>>, except when it returns FALSE with
-	<<bfd_errno>> set to <<bfd_error_file_ambiguously_recognized>>.  In that
-	case, if @var{matching} is not NULL, it will be filled in with
-	a NULL-terminated list of the names of the formats that matched,
-	allocated with <<malloc>>.
-	Then the user may choose a format and try again.
-
-	When done with the list that @var{matching} points to, the caller
-	should free it.
-*/
-
-bool
-bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
-{
-  return bfd_check_format_matches_lto (abfd, format, matching, false);
-}
-
 /*
 FUNCTION
 	bfd_set_format
diff --git a/bfd/plugin.c b/bfd/plugin.c
index 1c72b748a8f..be9d1e58bf3 100644
--- a/bfd/plugin.c
+++ b/bfd/plugin.c
@@ -196,13 +196,17 @@ bfd_plugin_get_symbols_in_object_only (bfd *abfd)
 	     abfd->filename, bfd_errmsg (bfd_get_error ()));
 	  return;
 	}
-      else if (!bfd_check_format (nbfd, bfd_object))
+      nbfd->plugin_format = bfd_plugin_no;
+      if (!bfd_check_format (nbfd, bfd_object))
 	{
 	  /* There is no object only section if it isn't a bfd_object
 	     file.  */
 	  bfd_close (nbfd);
 	  return;
 	}
+
+      /* Copy LTO type derived from input sections.  */
+      abfd->lto_type = nbfd->lto_type;
     }
   else
     {
@@ -239,6 +243,7 @@ bfd_plugin_get_symbols_in_object_only (bfd *abfd)
 
   /* Open the file containing object only section.  */
   nbfd = bfd_openr (object_only_file, NULL);
+  nbfd->plugin_format = bfd_plugin_no;
   if (!bfd_check_format (nbfd, bfd_object))
     {
       (*_bfd_error_handler)
diff --git a/binutils/nm.c b/binutils/nm.c
index a5d56311dde..94333042ee2 100644
--- a/binutils/nm.c
+++ b/binutils/nm.c
@@ -801,7 +801,8 @@ filter_symbols (bfd *abfd, bool is_dynamic, void *minisyms,
       if (sym == NULL)
 	continue;
 
-      if (bfd_lto_slim_symbol_p (abfd, sym->name)
+      if (!bfd_plugin_target_p (abfd->xvec)
+	  && bfd_lto_slim_symbol_p (abfd, sym->name)
 	  && report_plugin_err)
 	{
 	  report_plugin_err = false;
@@ -1484,7 +1485,8 @@ display_rel_file (bfd *abfd, bfd *archive_bfd)
 
   /* lto_type is set to lto_non_ir_object when a bfd is loaded with a
      compiler LTO plugin.  */
-  if (bfd_get_lto_type (abfd) == lto_slim_ir_object)
+  if (!bfd_plugin_target_p (abfd->xvec)
+      && bfd_get_lto_type (abfd) == lto_slim_ir_object)
     {
       report_plugin_err = false;
       non_fatal (_("%s: plugin needed to handle lto object"),
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
index 5774711abe6..3404bec1d08 100644
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -170,6 +170,8 @@ static bool sections_removed;
 #if BFD_SUPPORTS_PLUGINS
 /* TRUE if all GCC LTO sections are to be removed.  */
 static bool lto_sections_removed;
+#else
+#define lto_sections_removed false
 #endif
 
 /* TRUE if only some sections are to be copied.  */
@@ -3687,6 +3689,8 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
       bool ok_object;
       const char *element_name;
 
+      this_element->is_strip_input = 1;
+
       element_name = bfd_get_filename (this_element);
       /* PR binutils/17533: Do not allow directory traversal
 	 outside of the current directory tree by archive members.  */
@@ -3745,11 +3749,10 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
 
 #if BFD_SUPPORTS_PLUGINS
       /* Ignore plugin target if all LTO sections should be removed.  */
-      ok_object = bfd_check_format_lto (this_element, bfd_object,
-					lto_sections_removed);
-#else
-      ok_object = bfd_check_format (this_element, bfd_object);
+      if (lto_sections_removed)
+	this_element->plugin_format = bfd_plugin_no;
 #endif
+      ok_object = bfd_check_format (this_element, bfd_object);
 
       /* PR binutils/3110: Cope with archives
 	 containing multiple target types.  */
@@ -3768,7 +3771,9 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
 
 #if BFD_SUPPORTS_PLUGINS
       /* Copy LTO IR file as unknown object.  */
-      if (bfd_plugin_target_p (this_element->xvec))
+      if ((!lto_sections_removed
+	   && this_element->lto_type == lto_slim_ir_object)
+	  || bfd_plugin_target_p (this_element->xvec))
 	ok_object = false;
       else
 #endif
@@ -3863,6 +3868,25 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
   return ok;
 }
 
+static bool
+check_format_object (bfd *ibfd, char ***obj_matching,
+		     bool no_plugins ATTRIBUTE_UNUSED)
+{
+#if BFD_SUPPORTS_PLUGINS
+  /* Ignore plugin target first if all LTO sections should be
+     removed.  Try with plugin target next if ignoring plugin
+     target fails to match the format.  */
+  if (no_plugins && ibfd->plugin_format == bfd_plugin_unknown)
+    {
+      ibfd->plugin_format = bfd_plugin_no;
+      if (bfd_check_format_matches (ibfd, bfd_object, obj_matching))
+	return true;
+      ibfd->plugin_format = bfd_plugin_unknown;
+    }
+#endif
+  return bfd_check_format_matches (ibfd, bfd_object, obj_matching);
+}
+
 /* The top-level control.  */
 
 static void
@@ -3946,6 +3970,8 @@ copy_file (const char *input_filename, const char *output_filename, int ofd,
       break;
     }
 
+  ibfd->is_strip_input = 1;
+
   if (bfd_check_format (ibfd, bfd_archive))
     {
       bool force_output_target;
@@ -3988,21 +4014,7 @@ copy_file (const char *input_filename, const char *output_filename, int ofd,
 			 input_arch, target_defaulted))
 	status = 1;
     }
-  else if (
-#if BFD_SUPPORTS_PLUGINS
-	   /* Ignore plugin target first if all LTO sections should be
-	      removed.  Try with plugin target next if ignoring plugin
-	      target fails to match the format.  */
-	   bfd_check_format_matches_lto (ibfd, bfd_object, &obj_matching,
-					 lto_sections_removed)
-	   || (lto_sections_removed
-	       && bfd_check_format_matches_lto (ibfd, bfd_object,
-						&obj_matching, false))
-#else
-	   bfd_check_format_matches_lto (ibfd, bfd_object, &obj_matching,
-					 false)
-#endif
-	   )
+  else if (check_format_object (ibfd, &obj_matching, lto_sections_removed))
     {
       bfd *obfd;
     do_copy:
@@ -5066,6 +5078,11 @@ strip_main (int argc, char *argv[])
 					       SECTION_CONTEXT_REMOVE)
 			  || !!find_section_list (".llvm.lto", false,
 					       SECTION_CONTEXT_REMOVE));
+  /* NB: Must keep .gnu.debuglto_* sections unless all GCC LTO sections
+     will be removed to avoid undefined references to symbols in GCC LTO
+     debug sections.  */
+  if (!lto_sections_removed)
+    find_section_list (".gnu.debuglto_*", true, SECTION_CONTEXT_KEEP);
 #endif
 
   i = optind;
diff --git a/ld/testsuite/ld-plugin/lto-binutils.exp b/ld/testsuite/ld-plugin/lto-binutils.exp
index 88d35171045..de017f0b946 100644
--- a/ld/testsuite/ld-plugin/lto-binutils.exp
+++ b/ld/testsuite/ld-plugin/lto-binutils.exp
@@ -355,3 +355,178 @@ run_cc_link_tests [list \
 	"tmpdir/libstrip-1b-fat-s.a" \
     ] \
 ]
+
+proc run_pr33246_test { llvm fat } {
+    global srcdir
+    global subdir
+    global plug_opt
+    global llvm_plug_opt
+    global ar
+    global CLANG_FOR_TARGET
+    global CC_FOR_TARGET
+    global NM
+    global READELF
+    global strip
+
+    set strip_flags "--strip-debug --enable-deterministic-archives"
+
+    set test pr33246
+    set testname "${test}${llvm}${fat} with $strip_flags"
+
+    if { "$llvm" == "-llvm" } {
+	# Skip native x32 and i?86 targets since system LLVMgold.so may
+	# not be compatible with native x32 and i?86 targets binutils.
+	if { [istarget "x86_64-*-linux*-gnux32"]
+	     || [istarget "i?86-*-*"]
+	     || ![info exists CLANG_FOR_TARGET]
+	     || [string match "" $llvm_plug_opt] } then {
+	    untested $testname
+	    return
+	}
+	set CC $CLANG_FOR_TARGET
+	set binutils_plug_opt "$llvm_plug_opt"
+    } else {
+	if { ![info exists CC_FOR_TARGET]
+	     || [string match "" $plug_opt] } then {
+	    untested $testname
+	    return
+	}
+	set CC $CC_FOR_TARGET
+	set binutils_plug_opt "$plug_opt"
+    }
+
+    append strip_flags " $binutils_plug_opt"
+
+    set src $srcdir/$subdir/${test}.c
+    set obj tmpdir/${test}${llvm}${fat}.o
+    set archive tmpdir/${test}${llvm}${fat}.a
+    set CFLAGS "-c -g -O2 -flto"
+    if { "$fat" == "-fat" } {
+	append CFLAGS " -ffat-lto-objects"
+    } else {
+	append CFLAGS " -fno-fat-lto-objects"
+    }
+
+    set cmd "$CC $CFLAGS -o $obj $src"
+    send_log "$cmd\n"
+    verbose "$cmd" 1
+    catch "exec $cmd" got
+    if ![string match "" $got] then {
+	send_log "$got\n"
+	verbose "$got" 1
+	fail "$testname ($obj)"
+	return
+    }
+
+    set cmd "$strip $strip_flags $obj -o ${obj}.strip"
+    send_log "$cmd\n"
+    verbose "$cmd" 1
+    catch "exec $cmd" got
+    if ![string match "" $got] then {
+	send_log "$got\n"
+	verbose "$got" 1
+	fail "$testname (strip $obj)"
+	return
+    }
+
+    set cmd "$NM $binutils_plug_opt ${obj}.strip"
+    send_log "$cmd\n"
+    verbose "$cmd" 1
+    catch "exec $cmd" got
+    if ![regexp "0+ T foo" $got] then {
+	send_log "$got\n"
+	verbose "$got" 1
+	fail "$testname (strip $obj)"
+	return
+    }
+
+    if { "$fat" == "-fat" } {
+	set cmd "$READELF -SW ${obj}.strip"
+	send_log "$cmd\n"
+	verbose "$cmd" 1
+	catch "exec $cmd" got
+	if [regexp " \.debug_" $got] then {
+	    send_log "$got\n"
+	    verbose "$got" 1
+	    fail "$testname (strip $obj)"
+	    return
+	}
+    } else {
+	set cmd "cmp $obj ${obj}.strip"
+	send_log "$cmd\n"
+	verbose "$cmd" 1
+	catch "exec $cmd" got
+	if ![string match "" $got] then {
+	    send_log "$got\n"
+	    verbose "$got" 1
+	    fail "$testname (strip $obj)"
+	    return
+	}
+    }
+
+    pass "$testname (strip $obj)"
+
+    set cmd "$ar $binutils_plug_opt -D -s -r -c $archive $obj"
+    send_log "$cmd\n"
+    verbose "$cmd" 1
+    catch "exec $cmd" got
+    if ![string match "" $got] then {
+	send_log "$got\n"
+	verbose "$got" 1
+	fail "$testname ($archive)"
+	return
+    }
+
+    set cmd "$strip $strip_flags $archive -o ${archive}.strip"
+    send_log "$cmd\n"
+    verbose "$cmd" 1
+    catch "exec $cmd" got
+    if ![string match "" $got] then {
+	send_log "$got\n"
+	verbose "$got" 1
+	fail "$testname (strip $archive)"
+	return
+    }
+
+    set cmd "$NM $binutils_plug_opt ${archive}.strip"
+    send_log "$cmd\n"
+    verbose "$cmd" 1
+    catch "exec $cmd" got
+    if ![regexp "0+ T foo" $got] then {
+	send_log "$got\n"
+	verbose "$got" 1
+	fail "$testname (strip $archive)"
+	return
+    }
+
+    if { "$fat" == "-fat" } {
+	set cmd "$READELF -SW ${archive}.strip"
+	send_log "$cmd\n"
+	verbose "$cmd" 1
+	catch "exec $cmd" got
+	if [regexp " \.debug_" $got] then {
+	    send_log "$got\n"
+	    verbose "$got" 1
+	    fail "$testname (strip $archive)"
+	    return
+	}
+    } else {
+	set cmd "cmp $archive ${archive}.strip"
+	send_log "$cmd\n"
+	verbose "$cmd" 1
+	catch "exec $cmd" got
+	if ![string match "" $got] then {
+	    send_log "$got\n"
+	    verbose "$got" 1
+	    fail "$testname (strip $archive)"
+	    return
+	}
+    }
+
+    pass "$testname (strip $archive)"
+}
+
+run_pr33246_test "" ""
+run_pr33246_test "" "-fat"
+run_pr33246_test "-llvm" ""
+run_pr33246_test "-llvm" "-fat"
diff --git a/ld/testsuite/ld-plugin/pr33246.c b/ld/testsuite/ld-plugin/pr33246.c
new file mode 100644
index 00000000000..cd0130cacdf
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr33246.c
@@ -0,0 +1,4 @@
+void
+foo (void)
+{
+}
-- 
2.50.1
